#include "SDL.h"

#include "RichTextString.h"
#include "../Media/Font.h"
#include "../Media/FontManager.h"

#include "components/utilities/String.h"

RichTextString::RichTextString(const std::string &text, FontName fontName,
	const Color &color, TextAlignment alignment, int lineSpacing, FontManager &fontManager)
	: text(text), fontName(fontName), color(color), alignment(alignment),
	lineSpacing(lineSpacing)
{
	// Get the font data associated with the font name.
	const Font &font = fontManager.getFont(fontName);

	// Get the height in pixels for all characters in the font.
	this->characterHeight = font.getCharacterHeight();

	// Get the character surfaces associated with each line of text.
	this->surfaceLists = [&text, &font]()
	{
		// Split the text on each newline. If the text is empty, then just add a space, 
		// so there doesn't need to be any "zero-character" special case.
		const std::vector<std::string> textLines =
			String::split((text.size() > 0) ? text : std::string(" "), '\n');

		std::vector<std::vector<const SDL_Surface*>> tempLists;

		// Go through each line of text and get the associated surface pointers.
		for (const auto &textLine : textLines)
		{
			std::vector<const SDL_Surface*> surfaces;

			// Add a surface pointer associated with each character.
			for (const char c : textLine)
			{
				const SDL_Surface *charSurface = font.getSurface(c);
				surfaces.push_back(charSurface);
			}

			tempLists.push_back(std::move(surfaces));
		}

		return tempLists;
	}();

	// Get the width of each line in pixels (for determining the longest line).
	this->lineWidths = [this]()
	{
		std::vector<int> widths;

		for (const auto &surfaceList : this->surfaceLists)
		{
			// Start a new count on the line widths.
			widths.push_back(0);

			// Get the combined widths for the current line's surfaces.
			for (const auto *surface : surfaceList)
			{
				widths.back() += surface->w;
			}
		}

		return widths;
	}();

	// Get the width and height for the texture (generated by a text box).
	this->dimensions = [this, lineSpacing]()
	{
		// Get the width in pixels for the texture.
		const int textureWidth = [this]()
		{
			// Get the width in pixels of the longest line.
			int maxWidth = 0;
			for (const int lineWidth : this->lineWidths)
			{
				if (lineWidth > maxWidth)
				{
					maxWidth = lineWidth;
				}
			}
			return maxWidth;
		}();

		// Get the height in pixels for the texture. Also include line spacing.
		const int lineCount = static_cast<int>(this->surfaceLists.size());
		const int textureHeight = (this->characterHeight * lineCount) +
			(lineSpacing * (lineCount - 1));

		return Int2(textureWidth, textureHeight);
	}();
}

RichTextString::RichTextString(const std::string &text, FontName fontName,
	const Color &color, TextAlignment alignment, FontManager &fontManager)
	: RichTextString(text, fontName, color, alignment, 0, fontManager) { }

const std::vector<std::vector<const SDL_Surface*>> &RichTextString::getSurfaceLists() const
{
	return this->surfaceLists;
}

const std::vector<int> &RichTextString::getLineWidths() const
{
	return this->lineWidths;
}

const std::string &RichTextString::getText() const
{
	return this->text;
}

FontName RichTextString::getFontName() const
{
	return this->fontName;
}

const Color &RichTextString::getColor() const
{
	return this->color;
}

const Int2 &RichTextString::getDimensions() const
{
	return this->dimensions;
}

TextAlignment RichTextString::getAlignment() const
{
	return this->alignment;
}

int RichTextString::getLineSpacing() const
{
	return this->lineSpacing;
}

int RichTextString::getCharacterHeight() const
{
	return this->characterHeight;
}
